[toc]
## 网络
<!-- ##### HTTP请求的哪些方法用过？什么时候选择get、post、put？他们有什么区别
？？？
##### http中的同步和异步
？？？
##### ipv6
？？？
##### 断点续传怎么实现？需要设置什么？
？？？
##### Ping是什么协议
？？？
##### 输入一个字符串，判断这个字符串是否是有效的IP地址
？？？
##### 图片上传
？？？
##### NSURLCache
？？？ -->


### HTTP
#### HTTP协议
HTTP是基于TCP的应用层协议
网络七层协议包含应用层、表示层、会话层 、传输层、网络层 、数据链路层、物理层
##### HTTP请求/响应报文结构
1.请求行：
GET /data/info.html HTTP/1.1
2.请求头部：
Keep-Alive:首部行用来表明该浏览器告诉服务器使用持续连接
Accept： 浏览器可接受的MIME类型。
Accept-Charset：浏览器可接受的字符集。
Accept-Encoding：浏览器能够进行解码的数据编码方式，比如gzip。Servlet能够向支持gzip的浏览器返回经gzip编码的HTML页面。许多情形下这可以减少5到10倍的下载时间。
Host： 客户机通过这个头告诉服务器，想访问的主机名。Host头域指定请求资源的Intenet主机和端口号，必须表示请求url的原始服务器或网关的位置。HTTP/1.1请求必须包含主机头域，否则系统会以400状态码返回。
User-Agent：User-Agent头域的内容包含发出请求的用户信息。浏览器类型，如果Servlet返回的内容与浏览器类型有关则该值非常有用。
Cookie：客户机通过这个头可以向服务器带数据，这是最重要的请求头信息之一。
...
3.空行:
它的作用是通过一个空行，告诉服务器请求头部到此为止。
4.请求体
若方法字段是GET，则此项为空，没有数据
若方法字段是POST,则通常来说此处放置的就是要提交的数据
##### HTTP的请求方式
GET:发送一个请求来取得服务器上的某一资源。参数都拼在URL上
POST:向服务器提交数据，参数放body里
PUT：PUT和POST极为相似，都是向服务器发送数据，但它们之间有一个重要区别，PUT通常指定了资源的存放位置，而POST则没有，POST的数据存放位置由服务器自己决定
DELETE：删除某一个资源
HEAD：HEAD和GET本质是一样的，区别在于HEAD不含有呈现数据
##### GET和POST的区别
其实GET和Post没有本质上的区别，都是通过TCP实现，你可以在Get的body里塞参数，也可以在POST的URL上拼参数，就看浏览器/客户端怎么去处理你发的请求
具体的请看https://www.cnblogs.com/logsharing/p/8448446.html
1.GET的请求参数一般以?分割拼接到URL后面，POST请求参数在Body里面
2.GET 参数长度限制为2048个字符，POST一般是没限制的
3.GET 请求由于参数裸露在 URL 中， 是不安全的，POST 请求则是相对安全。之所以说是相对安全，是因为，如果 POST 虽然参数非明文，但如果被抓包，GET 和 POST 一样都是不 安全的。(HTTPS 该用还是得用)
4，在响应时，GET产生一个TCP数据包;POST产生两个TCP数据包(这个也是为什么Get比Post快的原因):
**对于GET方式的请求，浏览器会把Header和实体主体一并发送出去，服务器响应200(返回数据);而对于POST，浏览器先发送Header，服务器响应100Continue，浏览器再发送实体主体，服务器响应200OK(返回数据)。**
##### GET相对POST的优势是什么?
最大的优势就是方便。GET的URL可以直接手输，从而GET请求中的URL可以被存在书签里，或者历史记录里
GET的速度也比较快，因为只有一个数据包
##### 为什么说HTTP协议是无状态的
即协议对于事务处理没有记忆能力。每次的请求都是独立的，它的执行情况和结果与前面的请求和之后的请求时无直接关系的，它不会受前面的请求应答情况直接影响，也不会直接影响后面的请求应答情况。也就是说服务器中没有保存客户端的状态，客户端必须每次带上自己的状态去请求服务器
标准的 HTTP 协议指的是不包括 cookies，session，application的HTTP协议
##### 什么是http的持久连接和非持久连接
非持久连接:每个连接处理一个请求-响应事务
持久连接:每个连接可以处理多个请求-响应事务
持久连接情况下，服务器发出响应后让TCP连接继续打开着。同一对客户/服务器之间的后续请求和响应可以通过这个连接发送。HTTP/1.0使用非持久连接。HTTP/1.1 默认使用持久连接<keep-alive>。关闭的时间由服务器设定
##### HTTP持久连接怎么判断一个请求是否结束的
Content-Length:
根据所接收字节数是否达到Content-length值，如果一样则表示数据发送完毕，断开连接
Transfer-Encoding:
当选择分块传输时，响应头中可以不包含Content-Length，服务器会先回复一个不带数据的报文(只有响应行和响应头和\r\n)，然后开始传输若干个数据块。当传输完若干个数据块后，需要再传输一个空的数据块，当客户端收到空的数据块时，则客户端知道数据接收完毕
Keep-Alive timeout：
Httpd守护进程，一般都提供了keep-alive timeout时间设置参数
##### HTTPS和HTTP的区别
HTTPS 协议 = HTTP 协议 + SSL/TLS 协议
SSL的全称是 Secure Sockets Layer，即安全套接层协议，是为网络通信提供安全及数据完整性的一种安全协议。
TLS的全称是 Transport Layer Security，即安全传输层协议
##### HTTPS的连接建立流程
HTTPS为了兼顾安全与效率，同时使用了对称加密和非对称加密。在传输的过程中会涉及到三个密钥:
服务器端的公钥和私钥，用来进行非对称加密
客户端生成的随机密钥，用来进行对称加密
- 客户端访问服务端
客户端会把客户端会把安全协议版本号、客户端支持的加密算法列表、随机数C发给服务端
- 服务端发送证书给客户端
服务端接收到客户端访问后，会和自己支持的加密算法列表进行比对，如果不符合，则断开连接
符合的话，会选择一种自己支持的算法选择：
一种对称算法(如AES)
一种公钥算法(如具有特定秘钥长度的RSA，非对称加密)
一种MAC算法发给客户端。
服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的。服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人。
在发送加密算法的同时还会把数字证书和随机数S发送给客户端
- 客户端验证server证书
会对server公钥进行检查，验证其合法性，如果发现发现公钥有问题，那么 HTTPS 传输就无法继续。
- 客户端组装会话秘钥
如果公钥合格，那么客户端会用服务器公钥来生成一个前主秘钥(Pre-Master Secret，PMS)，并通过该前主秘钥和随机数C、S来组装成会话秘钥
- 客户端将前主秘钥加密发送给服务端
是通过服务端的公钥来对前主秘钥进行非对称加密，发送给服务端
- 服务端通过私钥解密得到前主秘钥
服务端接收到加密信息后，用私钥解密得到主秘钥。
- 服务端组装会话秘钥
服务端通过前主秘钥和随机数C、S来组装会话秘钥。
至此，服务端和客户端都已经知道了用于此次会话的主秘钥。
- 数据传输
客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。
同理，服务端收到客户端发送来的密文，用服务端密钥对其进行对称解密，得到客户端发送的数据。
总结：
会话秘钥 = random S + random C + 前主秘钥
HTTPS连接建立过程使用非对称加密，而非对称加密是很耗时的一种加密方式
后续通信过程使用对称加密，减少耗时所带来的性能损耗
其中，对称加密加密的是实际的数据，非对称加密加密的是对称加密所需要的客户端的密钥。
![](/images/https01.png)
简而言之：
C告诉S要请求了，然后服务端会吧自己的公钥和证书发给C，然后C验证后会生成一个PMS，然后用C刚给的公钥加密发给C。C再用自己的私钥解密刚发C发给自己的PMS，这个就是非对称加密。之后，大家就用PMS加密后进行会话传数据
##### 对称加密和非对称加密
对称加密：
用一套密钥进行加密
对称加密通常有 DES,IDEA,3DES 加密算法。

非对称加密：
用公钥和私钥来加解密的算法
公钥(Public Key)与私钥(Private Key)是通过一种算法得到的一个密钥对(即一个公钥和一个私钥)， 公钥是密钥对中公开的部分，私钥则是非公开的部分,私钥通常是保存在本地。由于私钥是保存在本地的，所以非对称加密相对与对称加密是安全的。但非对称加密比对称加密耗时(100倍以上),所以通常要结合对称加密来使用。
而为了确保客户端能够确认公钥就是想要访问的网站的公钥，引入了数字证书的概念，由于证书存在一级一级的签发过程，所以就出现了证书链，在证书链中的顶端的就是根CA
#### TCP
##### TCP的特点
面向连接：
使用TCP协议通信的双方必须先建立连接，然后才能开始数据的读写
- 可靠传输：
每个TCP报文段都必须得到接收方的应答，才能认为这个TCP报文段传输成功
如果在定时时间内未收到应答，它将重新发送该报文段
- 面向字节流：
TCP的字节流服务的表现形式就体现在，发送端执行的写操作数和接收端执行的读操作次数之间没有任何数量关系，当发送端应用程序连续执行多次写操作的时，TCP模块先将这些数据放入TCP发送缓冲区中。当TCP模块真正开始发送数据的时候，发送缓冲区中这些等待发送的数据可能被封装成一个或多个TCP报文段发出
- 全双工服务：
TCP连接是全双工的，即双方的数据读写可以通过一个连接进行
TCP协议的这种连接是一对一的，所以基于广播和多播（目标是多个主机地址）的应用程序不能使用TCP服。而无连接协议UDP则非常适合于广播和多播
##### 三次握手
用于建立连接，主要字段是SYN
第一次：
C向S发送一个特殊TCP报文，报文首部的SYN被置为1，并塞入一个client_isn，然后C的状态改为SYN_SENT，并等待S报文
第二次：
S收到报文段后会为该TCP连接分配TCP缓存和变量，
也发送一个同样的特殊TCP报文，把SYN置为1，塞入刚才的client_isn+1，再塞入一个server_isn，状态置为SYN_RCVD，并等待C报文
第三次：
C收到报文后也会为TCP连接分配缓存和变量，
再次向S发送一个报文表示连接确认，报文段的SYN会置为0，且server_isn+1，状态置为ESTABLISHED状态
当S收到这个报文后，S的状态也改为ESTABLISHED状态
##### 四次挥手
用于终止连接,主要字段是FIN
第一步:
C发送特殊报文，FIN为1，进入FIN_WAIT_1状态，等待S的报文
第二步：
S收到后会发送一个确认报文，S的状态变成CLOSE_WAIT，C收到该报文段后，进入FIN_WAIT_2状态，等待S的FIN比特置为1的报文段
第三部：
S会发送FIN为1的特殊报文，并且进入LAST_ACK状态
第四部：
C收到FIN为1的报文后，向S发送一个确认报文段，并进入TIME_WAIT状态。TIME_WAIT通常会等待2个最长报文段寿命，经过等待后，连接就正式关闭，重新进入 CLOSED 状态，客户端所有资源将被释放，S也是收到报文后等待一会，并关闭
![](/images/3wo4zhao.png)

##### 三次握手的作用
举例：已失效的连接请求报文段
client发送了第一个连接的请求报文，但是由于网络不好，这个请求没有立即到达服务端，而是在某个网络节点中滞留了，直到某个时间才到达server。
本来这已经是一个失效的报文，但是server端接收到这个请求报文后，还是会想client发出确认的报文，表示同意连接。
假如不采用三次握手，那么只要server发出确认，新的建立就连接了，但其实这个请求是失效的请求，client是不会理睬server的确认信息，也不会向服务端发送确认的请求。但是server认为新的连接已经建立起来了，并一直等待client发来数据，这样，server的很多资源就没白白浪费掉了。
采用三次握手就是为了防止这种情况的发生，server会因为收不到确认的报文，就知道client并没有建立连接。这就是三次握手的作用。
##### 为什么是四次挥手而不是三次?
三次握手里的第二步：S准备资源，将状态置为SYN_RCVD，发送SYN=1, seq, ACK
在挥手里变成了S置为CLOSE_WAIT状态，先发送一个ACK，再发送FIN, seq，状态置为LAST_ACK
其实S收到了这个消息后还会询问App，你是否还要发送东西，我要不要关，不管你咋样，我先告诉C，所以就先发送ACK，如有S还有东西发，就继续发，完事了之后，就发送FIN, seq告诉C我这也好了，不发东西了，可以关了。所以是四次挥手
##### 为什么建立连接只用三次握手，而断开连接却要四次挥手?
这个问题最好是结合三握四挥的图来看。。。
在三次握手中，其实在第二部S发送确认报文中进入SYN_RCVD这个状态这一步对应的是四次挥手的第二部和第三部。。三握中把收到和确认两个合并到了一起（S同意建立连接，并且在等待），变成了四挥中的：第二部：同意断开，进入Close_WAIT，和第三部的发送FIN特殊报文
##### 客户端为什么在TIME_WAIT后必须等待2MSL时间呢
因为C最后发送给S的确认报文可能会丢失，所以S会不停的发第三部的FIN报文。如果C发送后就关闭，那么S的资源是无法释放的。而如果等待2MSL的话C就能在2MSL时间内收到重传的FIN报文段
总结来说就是：为了保证客户端发送的最后一个ACK报文段能够到达服务端。
##### TCP在创建连接时，为什么需要三次握手而不是两次或四次
先说四次，其实原本四次挥手和三次握手是对应的，只不过握手吧2，3步合并了，如果是4部就浪费了
如果是两次，再看刚才的那个失效链接问题。如果两次的话等服务端收到后就开始准备资源分配内存建立连接，但是其实第一次握手是失效的，那么C是不会理睬S的第二次握手信息的，这样就白白浪费资源了
#### 其他
##### App网络层有哪些优化策略？
对传输的数据进行压缩，减少传输的数据
使用缓存手段减少请求的发起次数（本地缓存+modify）
使用策略来减少请求的发起次数，比如在上一个请求未着地之前，不进行新的请求
避免网络抖动，提供重发机制（失败容灾）
优化DNS解析和缓存（HTTPDNS）

##### Cookie和Session
cookie主要是用来记录用户状态，区分用户，状态保存在客户端
1.如果不希望Cookie在HTTP等非安全协议中传输，可以设置Cookie的secure属性为true。浏览器只会在HTTPS和SSL等安全协议中传输此类Cookie
2.此外，secure属性并不能对Cookie内容加密，因而不能保证绝对的安全性。如果需要高安全性，需要在程序中对Cookie内容加密、解密，以防泄密
3.也可以设置cookie为HttpOnly，如果在cookie中设置了HttpOnly属性，那么通过js脚本将无法读取到cookie信息，这样能有效的防止 XSS(跨站脚本攻击)攻击

Session 是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了

Cookie和Session的区别:
1、cookie数据存放在客户的浏览器上，session数据放在服务器上。
2、cookie相比session不是很安全，别人可以分析存放在本地的cookie并进行cookie 欺骗,考虑到安全应当使用session。
3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能,考虑到减轻服务器性能方面，应当使用cookie。
4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。而session存储在服务端，可以无限量存储
5、所以:将登录信息等重要信息存放为 session;其他信息如果需要保留，可以放在 cookie 中

##### IPv4编址
每个IP地址(IPv4)长度为32比特(4字节)，按点分十进制记法书写，即地址中的每个字节都用它的十进制形式书写，各字节间以点.隔开，比如193.32.122.30

##### 什么是DNS，什么是DNS解析
DNS（Domain Name System，域名系统），万维网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。普通的请求都是找的LocalDNS，所以有可能会出现被劫持的情况
DNS劫持，由于域名->IP这个过程中，其解析是基于UDP 协议实现，所以报文是明文状态，可能会在请求过程中被监测，然后攻击者做一些自己的处理，比如返回假的IP地址或者什么都不做使请求失去响应，其效果就是对特定的网络不能反应或访问的是假网址。
![](/images/dns01.png)

##### DNS存在的问题
- 安全问题
可能会被劫持
- 域名缓存问题
本地做一个缓存，直接返回缓存数据。可能会导致全局负载均衡失败，因为上次进行的缓存，不一定是这次离客户最近的地方，可能会绕远路。
- 域名转发问题
如果是A运营商将解析的请求转发给B运营商，B去权威DNS服务器查询的话，权威服务器会认为你是B运营商的，就返回了B运营商的网站地址，结果每次都会夸运营商
- 域名更新问题（解析延迟）
本地DNS服务器是由不同地区，不同运营商独立部署的，对域名解析缓存的处理上，有区别，有的会偷懒忽略解析结果TTL的时间限制，导致服务器没有更新新的ip而是指向旧的ip，DNS的查询过程需要递归遍历多个DNS服务器，才能获得最终结果。可能会带来一定的延时。

##### 什么是HTTPDNS
定义：不走传统的DNS解析，而是自己搭建基于HTTP协议的DNS服务器集群，分布在多个地点和多个运营商，当客户端需要DNS解析的时候，直接通过HTTP协议进行请求这个服务器集群，获得就近的地址
![](/images/httpdns01.png)

##### 如何解决DNS劫持
HTTPDNS:
**DNS协议**使用的是**UDP协议**向服务器的53端口进行请求。可以使用HttpDNS的方案,使用HTTP协议向DNS服务器的80端口进行请求,来规避DNS劫持.在终端上，可以更换DNS服务器，不管手机还是电脑，都能手动配置DNS
IP访问：
直接用IP进行访问，绕过域名解析，直接访问

##### 打开一个web页面从发送网络请求到页面展示都做了啥
1、输入网址
2、DNS解析
3、建立tcp连接
4、客户端发送HTPP请求
5、服务器处理请求　
6、服务器响应请求
7、浏览器展示HTML
8、浏览器发送请求获取其他在HTML中的资源。

##### Charles抓HTTPS的包的原理是什么
Charles作为中间人，对客户端伪装成服务端，对服务端伪装成客户端。简单来说：
截获客户端的HTTPS请求，伪装成中间人客户端去向服务端发送HTTPS请求
接受服务端返回，用自己的证书伪装成中间人服务端向客户端发送数据内容。
**反抓包策略**
为了防止中间人攻击，可以使用SSL-Pinning的技术来反抓包。
可以发现中间人攻击的要点的伪造了一个假的服务端证书给了客户端，客户端误以为真。解决思路就是，客户端也预置一份服务端的证书，比较一下就知道真假了。
SSL-pinning有两种方式： 证书锁定（Certificate Pinning） 和公钥锁定（ Public Key Pinning）。
证书锁定
需要在客户端代码内置仅接受指定域名的证书，而不接受操作系统或浏览器内置的CA根证书对应的任何证书，通过这种授权方式，保障了APP与服务端通信的唯一性和安全性，因此客户端与服务端（例如API网关）之间的通信是可以保证绝对安全。但是CA签发证书都存在有效期问题，缺点是在 证书续期后需要将证书重新内置到APP中。
公钥锁定
提取证书中的公钥并内置到客户端中，通过与服务器对比公钥值来验证连接的正确性。制作证书密钥时，公钥在证书的续期前后都可以保持不变（即密钥对不变），所以可以避免证书有效期问题，一般推荐这种做法。
https://juejin.im/post/6844903809068564493


#### Socket
##### 长连接为什么要保持心跳
国内移动无线网络运营商在链路上一段时间内没有数据通讯后, 会淘汰NAT表中的对应项, 造成链路中断。而国内的运营商一般NAT超时的时间为5分钟，所以通常我们心跳设置的时间间隔为3-5分钟。

##### 长连接选择TCP协议还是UDP协议？
使用TCP进行数据传输的话，简单、安全、可靠，但是带来的是服务端承载压力比较大。
使用UDP进行数据传输的话，效率比较高，带来的服务端压力较小，但是需要自己保证数据的可靠性，不作处理的话，会导致丢包、乱序等问题。
如果你的技术团队实力过硬，你可以选择UDP协议，否则还是使用TCP协议比较好。据说腾讯IM就是使用的UDP协议，然后还封装了自己的私有协议，来保证UDP数据包的可靠传输。

##### 为什么要维持心跳包，没有心跳包为什么链接会断开
如果是正常终止客户端进程，系统会对进程正在占用的资源进行回收。此时客户端所占用的socket端口会被释放，服务器端也会被告知对方断开socket连接了，因此终止与该客户端的连接。
而如果客户端非正常断开（比如客户端主机突然断电），则客户端的操作系统会在第一时间产生中断，保护操作系统。哪个操作系统还会特意耗费时间去回收socket资源←_←。所以即便客户端明明已经断开了连接，但服务器却迟迟没办法知道客户端断开的消息。因此会在较长一段时间内不会告诉编程者“某客户端已断开”，即便你写了在客户端断开后立刻回收资源的代码。
保持客户端与服务器长连接的话，心跳包是必不可少的。设定阈值n，心跳间隔时间T，当服务器在n*T的时间内没有听到客户端的心跳，那么就可以判定客户端“死亡”了，主动与它断开连接，回收资源。