[toc]
## 计算机知识
##### 计算机计量单位换算
1Byte = 8 Bit 
1KB   = 1024 Bytes
1MB   = 1024 KBww
##### 加密方式
加密方式：对称加密，非对称加密（跳转HTTPS）
加密算法：MD5,SHA1,SHA256等等
##### MVVM和MVC
？？？？
##### 封装继承多态，重载重写
多态：多态是同一个行为具有多个不同表现形式或形态的能力
OC中的多态是不同对象对同一消息的不同响应方式，子类通过重写父类的方法来改变同一方法的实现，体现多态性
A的eat打印A eat
B的eat打印B eat
重写不说了
重载：函数名相同,函数的参数列表不同(包括参数个数和参数类型)，至于返回类型可同可不同。重载发生在同一个类的不同函数之间，是横向的。重载和多态性无关
##### 哈希表和哈希函数
哈希表又叫散列表，是根据关键码值（Key-Value）而直接进行访问的数据结构，也就是我们常用到的map。哈希表的本质是一个数组，数组中每一个元素称为一个箱子(bin)，箱子中存放的是键值对
哈希函数：也称为是散列函数，是Hash表的映射函数，它可以把任意长度的输入变换成固定长度的输出，该输出就是哈希值（哈希算法）。哈希函数能使对一个数据序列的访问过程变得更加迅速有效，通过哈希函数数据元素能够被很快的进行定位。如果一个函数实现了哈希算法，就称这个函数为哈希函数
##### 字典的工作原理
hash表其实也是一个数组，区别数组的地方是它会建立存储的值到存储的下标索引的一个映射，也就是散列函数。
我们来举一个通俗易懂的例子：
现在我们有个hash表，表长度count = 16，现在我们依次把3，12，24，30依次存入hash表中。
首先我们来约定一个简单的映射关系（哈希函数）：存储的索引下表(index) = 存储值(value) % hash表长度(count)；
算下来hash表的存储分布是这样的：hash[3] = 3、hash[12] = 12、hash[8] = 24、hash[14] = 30
当我们给出24的时候，求出hash表中是否存有24？
此时，按照原先约定的映射关系：index = 24 % 16 = 8，然后我们在hash[8]查询等于24。这样，通过数组需要O(n)的时间复杂度，通过hash表只需要O(1)
如果要存入19的时候，就出现了哈希碰撞，因为19 % 16 = 3,这个时候hash[3] = 3，所以这个数组不是简单的数组，这个数组的每一个元素是一个链表。
![](/images/hash01.jpg)
所以这里就多出来一个概念就是负载因子和自动扩容。因为如果长度不变，存入的数据越多，那么碰撞的概率就越大，他们的比值就是负载因子，当负载因子达到一定的值之后，就要对Hash表进行扩容
https://www.jianshu.com/p/0d7cd6341f65
##### 内存中的5大区分别是什么
栈区(stack):由编译器自动分配释放存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。
堆区(heap):一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。注意它与 数据结构中的堆是两回事，分配方式倒是类似于链表。
全局区(静态区)(static):全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。
常量区:常量就是放在这里的。程序结束后由系统释放。
程序代码区:存放函数体的二进制代码。
##### 进程之间如何通信
- 管道
- 消息队列
- 共享内存
- 信号量（信号量用于进程间同步，若要在进程间传递数据需要结合共享内存）
##### 了解编译的过程么？分为哪几个步骤？
1.预编译
- 展开宏定义，检查语法错误
2.编译
- 词法分析，语法分析，语义分析（生成语法树）
- 中间代码生成，源码级优化，比如把1+2优化为3。实现不同的平台代码转换为机器代码，实现跨平台。
- 目标代码生成
3.汇编：汇编器将汇编代码转变成机器指令
- 静态链接：链接器将各个已经编译成机器指令的目标文件链接起来，经过重定位过后输出一个可执行文件。
- 装载：装载可执行文件、装载其依赖的共享对象。
- 动态链接：动态链接器将可执行文件和共享对象中需要重定位的位置进行修正。
- 进程的控制权转交给程序入口，程序终于运行起来了。
##### 静态链接了解么？静态库和动态库的区别？
静态链接是指将多个目标文件合并为一个可执行文件，直观感觉就是将所有目标文件的段合并。需要注意的是可执行文件与目标文件（编译之后的文件）的结构基本一致，不同的是是否“可执行”。
静态库：链接时完整地拷贝至可执行文件中，被多次使用就有多份冗余拷贝。
动态库：链接时不复制，程序运行时由系统动态加载到内存，供程序调用，系统只加载一次，多个程序共用，节省内存。

