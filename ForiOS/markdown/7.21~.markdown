[toc]
##### 编译链接的过程
1.预处理：把宏替换，删除注释，展开头文件，产生 .i 文件。
2.编译：把之前的 .i 文件转换成汇编语言，产生 .s文件。
3.汇编：把汇编语言文件转换为机器码文件，产生 .o 文件。
4.链接：在一个文件中可能会到其他文件，因此，还需要将编译生成的目标文件和系统提供的文件组合到一起，这个过程就是链接。经过链接，最后生成可执行文件

##### weak属性如何自动置nil的
请回顾对象的释放过程，dealloc的实现机制
objc_rootdealooc
rootdealloc
objct_dispose
objc_destructInstance
    object_cxxDestruct:判断有没有关联Cpp的东西，删除掉
    _object_remove_assocations:去除和这个对象assocate的对象
    objc_clear_deallocating
就是这个objc_clear_deallocing，会去查找sideTables里对应存储的表，并且清除对象

##### 如何手动取消KVO
实现automaticallyNotifiesObservers方法

##### 方法cache表是如何存储方法的（缓存策略）得好好用笔模拟下
```
struct cache_t {
    struct bucket_t *_buckets;  //bucket_t则是存放着imp和key，用来缓存方法的散列/哈希表
    mask_t _mask;       //mask是缓存池的最大容量， 这个值=散列表长度 - 1
    mask_t _occupied;   //occupied是缓存池缓存的方法数量
    struct bucket_t *buckets();
    mask_t mask();
    mask_t occupied();
    mask_t capacity();  //容量
    bool canBeFreed();
    void expand();
    ........
}
struct bucket_t {
private:
    cache_key_t _key;
    IMP _imp;
}
```
这里简要介绍一下散列表。首先散列表本质上就是一个数组
在往散列表里面添加成员的时候，首先需要借助key计算出一个index，也就是cache_hash函数，然后再将元素插入散列表的index位置
根据key计算出index值的这个算法称作散列算法，这个算法可以由你自己设计，总之目的就是尽可能减少不同的key得出相同index的情况出现，这种情况被称作哈希碰撞，同时还要保证得出的index值在合理的范围。index越大，意味着对应的散列表的长度越长，这是需要占用实际物理空间的，而我们的内存是有限的。散列表是一种通过牺牲一定空间，来换取时间效率的设计思想。
我们通过key计算出的index大小是随机的，无顺序的，因此在方法缓存的过程中，插入的顺序也是无顺序的
而且可以预见的是，散列表里面再实际使用中会有很多位置是空着的，比如散列表长度为16，最终值存储了10个方法，散列表长度为64，最终可能只会存储40个方法，有一部分空间终究是要被浪费的。但是却提高查找的效率。这既是所谓的空间换时间。
进入正题：
再介绍一下苹果这里所采用的散列算法，其实很简单，如下
index = @selector(XXXX) & mask
根据&运算的特点，可以得知最终index <= mask，而mask = 散列表长度 - 1，也就是说 0 <= index <= 散列表长度 - 1，这实际上覆盖了散列表的索引范围。
而刚刚我们还提到过一个问题——哈希碰撞，也就是不同的key得到相同的index，这个问题处理就是find方法
find查找大概就是是把散列表头尾连起来，从index开始，遍历一遍查找，当走过一圈之后，如果没有找到则返回0（bucket->key() == 0），就说明该位置上是空的，没有缓存过方法，是一个unused slot(未使用的槽口)，因此可以进行插入操作bucket->set(key, imp);，也就是将方法缓存到这个位置上
开辟方法不仅仅是在老缓存池基础上进行扩容，开辟新的buckets，释放老的buckets，因为苹果是通过哈希表进行缓存，并且散列算法是index = @selector(XXXX) & mask，扩容后mask发生了变化，所以里面缓存方法的index也都要发生变化，为了提高缓存效率，创建了新的buckets，老的buckets就会被释放掉，所以当容量达到最大值的3/4时，开始2倍扩容，扩容时会完全抹除旧的buckets，并且创建新的buckets代替，之后把最近一次临界的imp和key缓存进来
这里面有详细的源码
https://www.jianshu.com/p/fcf8d17121e3

##### Notification和多线程
接收通知处理代码线程 由发出通知的线程决定
如果发送线程是在异步，则接收的线程也是在异步
这里有一个NotificationQueue的东西，没有用过，但是写的是一个双向链表，用于管理通知发送时机(异步发送)，比如runloop空闲发送，尽快发送，立刻发送。Queue依赖runloop，子线程的话得要run.runloop,最终还是通过NSNotificationCenter进行发送通知。所谓异步，指的是非实时发送而是在合适的时机发送，并没有开启异步线程

##### 在方法调用的时候，方法查询-> 动态解析-> 消息转发 之前做了什么
这个问题其实是问一个对象，调用他的方法是什么步骤
首先是看rw_t里的cache是否有对应的方法，如果找到就调用，没找到会往cache里加方法（这里涉及到cache的缓存），然后从methodlist里找，找不到再往父方法里面找，还不行就开始走转发流程（转发三部曲）

##### 出自
https://blog.csdn.net/AAjjx/article/details/106282568

##### 内存告急的处理

##### 封装继承多态，重载重写
多态：多态是同一个行为具有多个不同表现形式或形态的能力
OC中的多态是不同对象对同一消息的不同响应方式，子类通过重写父类的方法来改变同一方法的实现，体现多态性
A的eat打印A eat
B的eat打印B eat
重写不说了
重载：函数名相同,函数的参数列表不同(包括参数个数和参数类型)，至于返回类型可同可不同。重载发生在同一个类的不同函数之间，是横向的。重载和多态性无关


### 网络

#### HTTP
##### HTTP协议
HTTP是基于TCP的应用层协议
网络七层协议包含应用层、表示层、会话层 、传输层、网络层 、数据链路层、物理层

##### HTTP请求/响应报文结构
1.请求行：
GET /data/info.html HTTP/1.1
2.请求头部：
Keep-Alive:首部行用来表明该浏览器告诉服务器使用持续连接
Accept： 浏览器可接受的MIME类型。
Accept-Charset：浏览器可接受的字符集。
Accept-Encoding：浏览器能够进行解码的数据编码方式，比如gzip。Servlet能够向支持gzip的浏览器返回经gzip编码的HTML页面。许多情形下这可以减少5到10倍的下载时间。
Host： 客户机通过这个头告诉服务器，想访问的主机名。Host头域指定请求资源的Intenet主机和端口号，必须表示请求url的原始服务器或网关的位置。HTTP/1.1请求必须包含主机头域，否则系统会以400状态码返回。
User-Agent：User-Agent头域的内容包含发出请求的用户信息。浏览器类型，如果Servlet返回的内容与浏览器类型有关则该值非常有用。
Cookie：客户机通过这个头可以向服务器带数据，这是最重要的请求头信息之一。
...
3.空行:
它的作用是通过一个空行，告诉服务器请求头部到此为止。
4.请求体
若方法字段是GET，则此项为空，没有数据
若方法字段是POST,则通常来说此处放置的就是要提交的数据

##### HTTP的请求方式
GET、POST、PUT、DELETE、HEAD、OPTIONS

##### GET和POST的区别
1.GET的请求参数一般以?分割拼接到URL后面，POST请求参数在Body里面
2.GET 参数长度限制为2048个字符，POST一般是没限制的
3.GET 请求由于参数裸露在 URL 中， 是不安全的，POST 请求则是相对安全。之所以说是相对安全，是因为，如果 POST 虽然参数非明文，但如果被抓包，GET 和 POST 一样都是不 安全的。(HTTPS 该用还是得用)
4，在响应时，GET产生一个TCP数据包;POST产生两个TCP数据包:
对于GET方式的请求，浏览器会把Header和实体主体一并发送出去，服务器响应200(返回数据);而对于POST，浏览器先发送Header，服务器响应100Continue，浏览器再发送实体主体，服务器响应200OK(返回数据)。

##### GET相对POST的优势是什么?
最大的优势就是方便。GET的URL可以直接手输，从而GET请求中的URL可以被存在书签里，或者历史记录里
GET的速度也比较快，因为只有一个数据包

##### 为什么说HTTP协议是无状态的
即协议对于事务处理没有记忆能力。每次的请求都是独立的，它的执行情况和结果与前面的请求和之后的请求时无直接关系的，它不会受前面的请求应答情况直接影响，也不会直接影响后面的请求应答情况。也就是说服务器中没有保存客户端的状态，客户端必须每次带上自己的状态去请求服务器
标准的 HTTP 协议指的是不包括 cookies，session，application的HTTP协议

##### 什么是http的持久连接和非持久连接
非持久连接:每个连接处理一个请求-响应事务
持久连接:每个连接可以处理多个请求-响应事务
持久连接情况下，服务器发出响应后让TCP连接继续打开着。同一对客户/服务器之间的后续请求和响应可以通过这个连接发送。HTTP/1.0使用非持久连接。HTTP/1.1 默认使用持久连接<keep-alive>。关闭的时间由服务器设定

##### HTTP持久连接怎么判断一个请求是否结束的
Content-Length:
根据所接收字节数是否达到Content-length值
Transfer-Encoding:
当选择分块传输时，响应头中可以不包含Content-Length，服务器会先回复一个不带数据的报文(只有响应行和响应头和\r\n)，然后开始传输若干个数据块。当传输完若干个数据块后，需要再传输一个空的数据块，当客户端收到空的数据块时，则客户端知道数据接收完毕

##### Cookie和Session
...
无状态是指协议对于事务处理没有记忆能力，协议的状态是指下一次传输可以“记住”这次传输信息的能力。