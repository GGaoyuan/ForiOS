[toc]
##### 编译链接的过程
1.预处理：把宏替换，删除注释，展开头文件，产生 .i 文件。
2.编译：把之前的 .i 文件转换成汇编语言，产生 .s文件。
3.汇编：把汇编语言文件转换为机器码文件，产生 .o 文件。
4.链接：在一个文件中可能会到其他文件，因此，还需要将编译生成的目标文件和系统提供的文件组合到一起，这个过程就是链接。经过链接，最后生成可执行文件

##### weak属性如何自动置nil的
请回顾对象的释放过程，dealloc的实现机制
objc_rootdealooc
rootdealloc
objct_dispose
objc_destructInstance
    object_cxxDestruct:判断有没有关联Cpp的东西，删除掉
    _object_remove_assocations:去除和这个对象assocate的对象
    objc_clear_deallocating
就是这个objc_clear_deallocing，会去查找sideTables里对应存储的表，并且清除对象

##### 如何手动取消KVO
实现automaticallyNotifiesObservers方法

##### 方法cache表是如何存储方法的（缓存策略）得好好用笔模拟下
```
struct cache_t {
    struct bucket_t *_buckets;  //bucket_t则是存放着imp和key，用来缓存方法的散列/哈希表
    mask_t _mask;       //mask是缓存池的最大容量， 这个值=散列表长度 - 1
    mask_t _occupied;   //occupied是缓存池缓存的方法数量
    struct bucket_t *buckets();
    mask_t mask();
    mask_t occupied();
    mask_t capacity();  //容量
    bool canBeFreed();
    void expand();
    ........
}
struct bucket_t {
private:
    cache_key_t _key;
    IMP _imp;
}
```
这里简要介绍一下散列表。首先散列表本质上就是一个数组
在往散列表里面添加成员的时候，首先需要借助key计算出一个index，也就是cache_hash函数，然后再将元素插入散列表的index位置
根据key计算出index值的这个算法称作散列算法，这个算法可以由你自己设计，总之目的就是尽可能减少不同的key得出相同index的情况出现，这种情况被称作哈希碰撞，同时还要保证得出的index值在合理的范围。index越大，意味着对应的散列表的长度越长，这是需要占用实际物理空间的，而我们的内存是有限的。散列表是一种通过牺牲一定空间，来换取时间效率的设计思想。
我们通过key计算出的index大小是随机的，无顺序的，因此在方法缓存的过程中，插入的顺序也是无顺序的
而且可以预见的是，散列表里面再实际使用中会有很多位置是空着的，比如散列表长度为16，最终值存储了10个方法，散列表长度为64，最终可能只会存储40个方法，有一部分空间终究是要被浪费的。但是却提高查找的效率。这既是所谓的空间换时间。
进入正题：
再介绍一下苹果这里所采用的散列算法，其实很简单，如下
index = @selector(XXXX) & mask
根据&运算的特点，可以得知最终index <= mask，而mask = 散列表长度 - 1，也就是说 0 <= index <= 散列表长度 - 1，这实际上覆盖了散列表的索引范围。
而刚刚我们还提到过一个问题——哈希碰撞，也就是不同的key得到相同的index，这个问题处理就是find方法
find查找大概就是是把散列表头尾连起来，从index开始，遍历一遍查找，当走过一圈之后，如果没有找到则返回0（bucket->key() == 0），就说明该位置上是空的，没有缓存过方法，是一个unused slot(未使用的槽口)，因此可以进行插入操作bucket->set(key, imp);，也就是将方法缓存到这个位置上
开辟方法不仅仅是在老缓存池基础上进行扩容，开辟新的buckets，释放老的buckets，因为苹果是通过哈希表进行缓存，并且散列算法是index = @selector(XXXX) & mask，扩容后mask发生了变化，所以里面缓存方法的index也都要发生变化，为了提高缓存效率，创建了新的buckets，老的buckets就会被释放掉，所以当容量达到最大值的3/4时，开始2倍扩容，扩容时会完全抹除旧的buckets，并且创建新的buckets代替，之后把最近一次临界的imp和key缓存进来
这里面有详细的源码
https://www.jianshu.com/p/fcf8d17121e3

##### Notification和多线程
接收通知处理代码线程 由发出通知的线程决定
如果发送线程是在异步，则接收的线程也是在异步
这里有一个NotificationQueue的东西，没有用过，但是写的是一个双向链表，用于管理通知发送时机(异步发送)，比如runloop空闲发送，尽快发送，立刻发送。Queue依赖runloop，子线程的话得要run.runloop,最终还是通过NSNotificationCenter进行发送通知。所谓异步，指的是非实时发送而是在合适的时机发送，并没有开启异步线程

##### 在方法调用的时候，方法查询-> 动态解析-> 消息转发 之前做了什么
这个问题其实是问一个对象，调用他的方法是什么步骤
首先是看rw_t里的cache是否有对应的方法，如果找到就调用，没找到会往cache里加方法（这里涉及到cache的缓存），然后从methodlist里找，找不到再往父方法里面找，还不行就开始走转发流程（转发三部曲）

##### 出自
https://blog.csdn.net/AAjjx/article/details/106282568

##### 内存告急的处理

##### 封装继承多态，重载重写
多态：多态是同一个行为具有多个不同表现形式或形态的能力
OC中的多态是不同对象对同一消息的不同响应方式，子类通过重写父类的方法来改变同一方法的实现，体现多态性
A的eat打印A eat
B的eat打印B eat
重写不说了
重载：函数名相同,函数的参数列表不同(包括参数个数和参数类型)，至于返回类型可同可不同。重载发生在同一个类的不同函数之间，是横向的。重载和多态性无关


### 网络

#### HTTP
##### HTTP协议
HTTP是基于TCP的应用层协议
网络七层协议包含应用层、表示层、会话层 、传输层、网络层 、数据链路层、物理层

##### HTTP请求/响应报文结构
1.请求行：
GET /data/info.html HTTP/1.1
2.请求头部：
Keep-Alive:首部行用来表明该浏览器告诉服务器使用持续连接
Accept： 浏览器可接受的MIME类型。
Accept-Charset：浏览器可接受的字符集。
Accept-Encoding：浏览器能够进行解码的数据编码方式，比如gzip。Servlet能够向支持gzip的浏览器返回经gzip编码的HTML页面。许多情形下这可以减少5到10倍的下载时间。
Host： 客户机通过这个头告诉服务器，想访问的主机名。Host头域指定请求资源的Intenet主机和端口号，必须表示请求url的原始服务器或网关的位置。HTTP/1.1请求必须包含主机头域，否则系统会以400状态码返回。
User-Agent：User-Agent头域的内容包含发出请求的用户信息。浏览器类型，如果Servlet返回的内容与浏览器类型有关则该值非常有用。
Cookie：客户机通过这个头可以向服务器带数据，这是最重要的请求头信息之一。
...
3.空行:
它的作用是通过一个空行，告诉服务器请求头部到此为止。
4.请求体
若方法字段是GET，则此项为空，没有数据
若方法字段是POST,则通常来说此处放置的就是要提交的数据

##### HTTP的请求方式
GET、POST、PUT、DELETE、HEAD、OPTIONS

##### GET和POST的区别
1.GET的请求参数一般以?分割拼接到URL后面，POST请求参数在Body里面
2.GET 参数长度限制为2048个字符，POST一般是没限制的
3.GET 请求由于参数裸露在 URL 中， 是不安全的，POST 请求则是相对安全。之所以说是相对安全，是因为，如果 POST 虽然参数非明文，但如果被抓包，GET 和 POST 一样都是不 安全的。(HTTPS 该用还是得用)
4，在响应时，GET产生一个TCP数据包;POST产生两个TCP数据包:
对于GET方式的请求，浏览器会把Header和实体主体一并发送出去，服务器响应200(返回数据);而对于POST，浏览器先发送Header，服务器响应100Continue，浏览器再发送实体主体，服务器响应200OK(返回数据)。

##### GET相对POST的优势是什么?
最大的优势就是方便。GET的URL可以直接手输，从而GET请求中的URL可以被存在书签里，或者历史记录里
GET的速度也比较快，因为只有一个数据包

##### 为什么说HTTP协议是无状态的
即协议对于事务处理没有记忆能力。每次的请求都是独立的，它的执行情况和结果与前面的请求和之后的请求时无直接关系的，它不会受前面的请求应答情况直接影响，也不会直接影响后面的请求应答情况。也就是说服务器中没有保存客户端的状态，客户端必须每次带上自己的状态去请求服务器
标准的 HTTP 协议指的是不包括 cookies，session，application的HTTP协议

##### 什么是http的持久连接和非持久连接
非持久连接:每个连接处理一个请求-响应事务
持久连接:每个连接可以处理多个请求-响应事务
持久连接情况下，服务器发出响应后让TCP连接继续打开着。同一对客户/服务器之间的后续请求和响应可以通过这个连接发送。HTTP/1.0使用非持久连接。HTTP/1.1 默认使用持久连接<keep-alive>。关闭的时间由服务器设定

##### HTTP持久连接怎么判断一个请求是否结束的
Content-Length:
根据所接收字节数是否达到Content-length值
Transfer-Encoding:
当选择分块传输时，响应头中可以不包含Content-Length，服务器会先回复一个不带数据的报文(只有响应行和响应头和\r\n)，然后开始传输若干个数据块。当传输完若干个数据块后，需要再传输一个空的数据块，当客户端收到空的数据块时，则客户端知道数据接收完毕

#### HTTPS、对称加密、非对称加密
##### HTTPS和HTTP的区别
HTTPS 协议 = HTTP 协议 + SSL/TLS 协议
SSL的全称是 Secure Sockets Layer，即安全套接层协议，是为网络通信提供安全及数据完整性的一种安全协议。
TLS的全称是 Transport Layer Security，即安全传输层协议

##### HTTPS的连接建立流程
HTTPS为了兼顾安全与效率，同时使用了对称加密和非对称加密。在传输的过程中会涉及到三个密钥:
服务器端的公钥和私钥，用来进行非对称加密
客户端生成的随机密钥，用来进行对称加密
1.客户端访问服务端
客户端会把客户端会把安全协议版本号、客户端支持的加密算法列表、随机数C发给服务端
2.服务端发送证书给客户端
服务端接收到客户端访问后，会和自己支持的加密算法列表进行比对，如果不符合，则断开连接
符合的话，会选择一种自己支持的算法选择：
一种对称算法(如AES)
一种公钥算法(如具有特定秘钥长度的RSA)
一种MAC算法发给客户端。
服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的。服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人。
在发送加密算法的同时还会把数字证书和随机数S发送给客户端
3.客户端验证server证书
会对server公钥进行检查，验证其合法性，如果发现发现公钥有问题，那么 HTTPS 传输就无法继续。
4.客户端组装会话秘钥
如果公钥合格，那么客户端会用服务器公钥来生成一个前主秘钥(Pre-Master Secret，PMS)，并通过该前主秘钥和随机数C、S来组装成会话秘钥
5.客户端将前主秘钥加密发送给服务端
是通过服务端的公钥来对前主秘钥进行非对称加密，发送给服务端
6.服务端通过私钥解密得到前主秘钥
服务端接收到加密信息后，用私钥解密得到主秘钥。
7.服务端组装会话秘钥
服务端通过前主秘钥和随机数C、S来组装会话秘钥。
至此，服务端和客户端都已经知道了用于此次会话的主秘钥。
8.数据传输
客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。
同理，服务端收到客户端发送来的密文，用服务端密钥对其进行对称解密，得到客户端发送的数据。
总结：
会话秘钥 = random S + random C + 前主秘钥
HTTPS连接建立过程使用非对称加密，而非对称加密是很耗时的一种加密方式
后续通信过程使用对称加密，减少耗时所带来的性能损耗
其中，对称加密加密的是实际的数据，非对称加密加密的是对称加密所需要的客户端的密钥。
![](/images/https01.png)
简而言之：
1：C告诉S要请求了，然后服务端会吧自己的公钥和证书发给C，然后C验证后会生成一个PMS，然后用C刚给的公钥加密发给C。C再用自己的私钥解密刚发C发给自己的PMS，这个就是非对称加密。之后，大家就用PMS加密后进行会话传数据

##### 对称加密和非对称加密
对称加密：
用一套密钥进行加密
对称加密通常有 DES,IDEA,3DES 加密算法。

非对称加密：
用公钥和私钥来加解密的算法
公钥(Public Key)与私钥(Private Key)是通过一种算法得到的一个密钥对(即一个公钥和一个私钥)， 公钥是密钥对中公开的部分，私钥则是非公开的部分,私钥通常是保存在本地。由于私钥是保存在本地的，所以非对称加密相对与对称加密是安全的。但非对称加密比对称加密耗时(100倍以上),所以通常要结合对称加密来使用。
而为了确保客户端能够确认公钥就是想要访问的网站的公钥，引入了数字证书的概念，由于证书存在一级一级的签发过程，所以就出现了证书链，在证书链中的顶端的就是根CA

#### TCP
##### TCP的特点
面向连接：
使用TCP协议通信的双方必须先建立连接，然后才能开始数据的读写
可靠传输：
每个TCP报文段都必须得到接收方的应答，才能认为这个TCP报文段传输成功
如果在定时时间内未收到应答，它将重新发送该报文段
面向字节流：
TCP的字节流服务的表现形式就体现在，发送端执行的写操作数和接收端执行的读操作次数之间没有任何数量关系，当发送端应用程序连续执行多次写操作的时，TCP模块先将这些数据放入TCP发送缓冲区中。当TCP模块真正开始发送数据的时候，发送缓冲区中这些等待发送的数据可能被封装成一个或多个TCP报文段发出
全双工服务：
TCP连接是全双工的，即双方的数据读写可以通过一个连接进行
TCP协议的这种连接是一对一的，所以基于广播和多播（目标是多个主机地址）的应用程序不能使用TCP服。而无连接协议UDP则非常适合于广播和多播

##### 三次握手
用于建立连接，主要字段是SYN
第一次：
C向S发送一个特殊TCP报文，报文首部的SYN被置为1，并塞入一个client_isn，然后C的状态改为SYN_SENT，并等待S报文
第二次：
S收到报文段后会为该TCP连接分配TCP缓存和变量，
也发送一个同样的特殊TCP报文，把SYN置为1，塞入刚才的client_isn+1，再塞入一个server_isn，状态置为SYN_RCVD，并等待C报文
第三次：
C收到报文后也会为TCP连接分配缓存和变量，
再次向S发送一个报文表示连接确认，报文段的SYN会置为0，且server_isn+1，状态置为ESTABLISHED状态
当S收到这个报文后，S的状态也改为ESTABLISHED状态

##### 四次挥手
用于终止连接,主要字段是FIN
第一步:
C发送特殊报文，FIN为1，进入FIN_WAIT_1状态，等待S的报文
第二步：
S收到后会发送一个确认报文，S的状态变成CLOSE_WAIT，C收到该报文段后，进入FIN_WAIT_2状态，等待S的FIN比特置为1的报文段
第三部：
S会发送FIN为1的特殊报文，并且进入LAST_ACK状态
第四部：
C收到FIN为1的报文后，向S发送一个确认报文段，并进入TIME_WAIT状态。TIME_WAIT通常会等待2个最长报文段寿命，经过等待后，连接就正式关闭，重新进入 CLOSED 状态，客户端所有资源将被释放，S也是收到报文后等待一会，并关闭

##### 三次握手的作用
举例：已失效的连接请求报文段
client发送了第一个连接的请求报文，但是由于网络不好，这个请求没有立即到达服务端，而是在某个网络节点中滞留了，直到某个时间才到达server。
本来这已经是一个失效的报文，但是server端接收到这个请求报文后，还是会想client发出确认的报文，表示同意连接。
假如不采用三次握手，那么只要server发出确认，新的建立就连接了，但其实这个请求是失效的请求，client是不会理睬server的确认信息，也不会向服务端发送确认的请求。但是server认为新的连接已经建立起来了，并一直等待client发来数据，这样，server的很多资源就没白白浪费掉了。
采用三次握手就是为了防止这种情况的发生，server会因为收不到确认的报文，就知道client并没有建立连接。这就是三次握手的作用。

##### 为什么建立连接只用三次握手，而断开连接却要四次挥手?
这个问题最好是结合三握四挥的图来看。。。
在三次握手中，其实在第二部S发送确认报文中进入SYN_RCVD这个状态这一步对应的是四次挥手的第二部和第三部。。三握中把收到和确认两个合并到了一起（S同意建立连接，并且在等待），变成了四挥中的：第二部：同意断开，进入Close_WAIT，和第三部的发送FIN特殊报文

##### 客户端为什么在TIME_WAIT后必须等待2MSL时间呢
因为C最后发送给S的确认报文可能会丢失，所以S会不停的发第三部的FIN报文。如果C发送后就关闭，那么S的资源是无法释放的。而如果等待2MSL的话C就能在2MSL时间内收到重传的FIN报文段
总结来说就是：为了保证客户端发送的最后一个ACK报文段能够到达服务端。

##### TCP在创建连接时，为什么需要三次握手而不是两次或四次
先说四次，其实原本四次挥手和三次握手是对应的，只不过握手吧2，3步合并了，如果是4部就浪费了
如果是两次，再看刚才的那个失效链接问题。如果两次的话等服务端收到后就开始准备资源分配内存建立连接，但是其实第一次握手是失效的，那么C是不会理睬S的第二次握手信息的，这样就白白浪费资源了

##### Cookie和Session
...
无状态是指协议对于事务处理没有记忆能力，协议的状态是指下一次传输可以“记住”这次传输信息的能力。




##### Runtime的内存优化
1.类数据结构变化
当类被Runtime加载之后，类的结构会发生一些变化，
CleanMemory加载后不会发生更改的内存块，class_ro_t属于Clean Memory，因为它是只读的
DirtyMemory运行时会进行更改的内存块，类一旦被加载，就会变成Dirty Memory，例如，我们可以在 Runtime 给类动态的添加方法
在介绍优化方法之前，我们先来看一下，在类加载之后类的结构变化：
在类加载到Runtime中后会被分配用于读取/写入数据的结构体class_rw_t
Tips：class_ro_t是只读的，存放的是编译期间就确定的字段信息；而class_rw_t是在 runtime 时才创建的，它会先将class_ro_t的内容拷贝一份，再将类的分类的属性、方法、协议等信息添加进去，之所以要这么设计是因为 Objective-C 是动态语言，你可以在运行时更改它们方法，属性等，并且分类可以在不改变类设计的前提下，将新方法添加到类中
优化可以吧rw里很多不会改变的方法放在一个新建的rw_ext里，rw_ext再指向ro，让一部分DirtyMemory变成CleanMemory


https://halfrost.com/objc_runtime_isa_class/



##### App的启动过程
https://www.cnblogs.com/lxlx1798/p/9256649.html
1.准备启动，系统调用exec()函数，根据exec函数指定的文件名找到可执行文件，就是在调用进程内部执行一个可执行文件。这里的可执行文件既可以是二进制文件，也可以是任何Unix下可执行的脚本文件

2.完成了初始化准备工作后，启动dyld。dyld作用：
    1.从kernel留下的原始调用栈引导和启动自己(调用dyldbootstrap::start()方法)
    2.动态链接库和可执行文件递归载入到内存中（imageLoader）,链接可执行文件
    3.找到main函数，准备参数并调用(返回了main函数地址，填入参数并调用main函数)
![](/images/dyld_01.jpg)
看到了栈底的dyldbootstrap::start()方法，继而调用了dyld::_main()方法，其中完成了刚才说的递归加载动态库过程，由于libSystem默认引入，栈中出现了libSystem_initializer的初始化方法。
当libSystem_initializer逐步调用到了_objc_init，这里就是objc和runtime的初始化入口。除了runtime环境的初始化外，_objc_init中绑定了新image被加载后的callback
![](/images/dyld_02.jpg)
可见dyld担当了runtime和ImageLoader中间的协调者，当新image加载进来后交由runtime大厨去解析这个二进制文件的符号表和代码。继续上面的断点法，断住神秘的+load函数
1.dyld开始将程序二进制文件初始化
2.交由ImageLoader读取image，其中包含了我们的类、方法等各种符号
3.由于runtime向dyld绑定了回调，当image加载到内存后，dyld会通知runtime进行处理
4.runtime接手后调用map_images做解析和处理，接下来load_images中调用call_load_methods方法，遍历所有加载进来的Class，按继承层级依次调用Class的load方法和其Category的load方法
至此，可执行文件中和动态库所有的符号（Class，Protocol，Selector，IMP，…）都已经按格式成功加载到内存中，被runtime所管理，再这之后，runtime的那些方法（动态添加Class、方法混合等等才能生效）

##### 重载load时需要手动添加@autoreleasepool么
不需要，在runtime调用load方法前后是加了objc_autoreleasePoolPush()和objc_autoreleasePoolPop()的。


##### SD里在查询磁盘的时候为什么会有一个ioQueue(SD怎么保证查找安全)
一个async(ioQueue)实现，一个串行队列，保证当前只有一个任务操作磁盘

##### SD查找Disk为什么要autoreleasepool
因为查询磁盘差的是NSData，得到一个UIImage，转换的时候会出现大量的临时变量

##### SD如何判断是JPEG，PNG，或者其他格式的？
通过二进制码，在磁盘缓存的时候拿到的是NSData，然后通过前缀0xFF,0x89等待，判断图片的格式

##### 如何设计一个缓存

##### SD是怎么做到URL不变，但是图片变化，让图片也变化的？
在完成了拿图片之后，有一个RefreshCache的枚举，里面有提到CacheControl。这个东西可以在ResponseHeader里看到（青花瓷抓包）
cache-control: max-age=31536000
last-modified: Tue, 26 Mar 2019 14:16:09 GMT
这俩就是这个问题的关键
如果last-modified在事件内，是不会请求的，直接用缓存，主要就是设置“If-Modified-Since”
这个字段得要后台支持，因为在Response的Header里

##### SD为什么要重写NSOperation
重写start方法要设置一些ResponseCache里的一些东西，是否要保存responseCache

##### NSString的内存问题

#### 网络安全
##### 如何解决DNS劫持
DNS解析发生在HTTP协议之前，DNS解析和DNS劫持和HTTP没有关系，DNS协议使用的是UDP协议向服务器的53端口进行请求。
可以使用HttpDNS的方案:使用HTTP协议向DNS服务器的80端口进行请求,来规避DNS劫持
在终端上，可以更换DNS服务器，不管手机还是电脑，都能手动配置DNS

##### Cookie和Session
cookie主要是用来记录用户状态，区分用户，状态保存在客户端
1.如果不希望Cookie在HTTP等非安全协议中传输，可以设置Cookie的secure属性为true。浏览器只会在HTTPS和SSL等安全协议中传输此类Cookie
2.此外，secure属性并不能对Cookie内容加密，因而不能保证绝对的安全性。如果需要高安全性，需要在程序中对Cookie内容加密、解密，以防泄密
3.也可以设置cookie为HttpOnly，如果在cookie中设置了HttpOnly属性，那么通过js脚本将无法读取到cookie信息，这样能有效的防止 XSS(跨站脚本攻击)攻击

Session 是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了

Cookie和Session的区别:
1、cookie数据存放在客户的浏览器上，session数据放在服务器上。
2、cookie相比session不是很安全，别人可以分析存放在本地的cookie并进行cookie 欺骗,考虑到安全应当使用session。
3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能,考虑到减轻服务器性能方面，应当使用cookie。
4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。而session存储在服务端，可以无限量存储
5、所以:将登录信息等重要信息存放为 session;其他信息如果需要保留，可以放在 cookie 中

##### IPv4编址
每个IP地址(IPv4)长度为32比特(4字节)，按点分十进制记法书写，即地址中的每个字节都用它的十进制形式书写，各字节间以点.隔开，比如193.32.122.30

三方库源码解读
https://github.com/huang303513/SourceCodeResearchAndExploration.git
