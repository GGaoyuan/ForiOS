[toc]
## 6.29
### GCD
#### Operation
区别：
1.GCD是C写的，轻量，写起来方便，Operation是GCD面向对象封装
2.NSOperation面向对象，所以能用KVO，对线程的控制更细，可以查看线程是否取消，结束，等状态，对于控制粒度Operation小，GCD写个顺序执行的逻辑会比operation复杂
3.很多时候只是会用到异步操作，不会有特别复杂的线程关系管理，所以苹果推崇的 且优化完善、运行快速的GCD是首选
4.对于顺序行，依赖关系的话GCD没有operation好用

#### 自旋锁与互斥锁（mutex）的区别
自旋锁和互斥锁的区别在于
自旋锁时候忙等，就是说上一个线程被锁后，当前线程不会休眠，而是不停的去检查锁是否可用，当上一个线程完事后当前线程立即执行
互斥锁是上一个线程被锁住后当前线程休眠，此时CPU会去执行其他任务。当上一个线程完成后，当前线程再被唤醒执行
优缺点：
自旋锁不会引起休眠，所以没有线程调度所以速度快，但是因为当前线程会不停检查是否解锁所以会占用CPU资源，所以自旋锁适合于那种很短时间的操作（sideTable,atomic），而不适合那种时间较长的锁。互斥锁正好反着
自旋锁：gcd信号量，atomic
互斥锁：@syncoized,pthread_mutex,NSLock,NSConditoin,NSConditionLock

## 7.1
### Runloop
#### 循环的细节
```
int32_t __CFRunLoopRun()
{
    //通知即将进入runloop
    __CFRunLoopDoObservers(KCFRunLoopEntry);
     
    do
    {
        // 通知将要处理timer和source
        __CFRunLoopDoObservers(kCFRunLoopBeforeTimers);
        __CFRunLoopDoObservers(kCFRunLoopBeforeSources);
         
        __CFRunLoopDoBlocks();  //处理非延迟的主线程调用
        __CFRunLoopDoSource0(); //处理UIEvent事件
         
        //GCD dispatch main queue
        CheckIfExistMessagesInMainDispatchQueue();
         
        // 即将进入休眠
        __CFRunLoopDoObservers(kCFRunLoopBeforeWaiting);
         
        // 等待内核mach_msg事件
        mach_port_t wakeUpPort = SleepAndWaitForWakingUpPorts();
         
        // Zzz...
         
        // 从等待中醒来
        __CFRunLoopDoObservers(kCFRunLoopAfterWaiting);
         
        // 处理因timer的唤醒
        if (wakeUpPort == timerPort)
            __CFRunLoopDoTimers();
         
        // 处理异步方法唤醒,如dispatch_async
        else if (wakeUpPort == mainDispatchQueuePort)
            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()
             
        // UI刷新,动画显示
        else
            __CFRunLoopDoSource1();
         
        // 再次确保是否有同步的方法需要调用
        __CFRunLoopDoBlocks();
         
    } while (!stop && !timeout);
     
    //通知即将退出runloop
    __CFRunLoopDoObservers(CFRunLoopExit);
}
```

#### 解释下事件响应过程
硬件的监听器发现有硬件的事件发生后（触摸，摇晃，锁屏等等），由IOKit生成一个IOEvent事件然后由MachPort转发给对应的App进程，然后source1会接受这个事件，调用ApplicationHandleEventQueue进行内部分发，然后将IOEvent包装成UIEvent进行处理分发，比如UIButton的点击，touchBegin等等
#### 解释一下手势识别的过程
当App收到ApplicationHandleEventQueue分发的IOEvent之后，会先canle掉当前的touchesBegin/Move/End的回调，并将对应的UIGestureRecognizer标记为待处理。
当runloop为将要进入休眠的时候（Beforewaiting），会获取到所有的UIGestureRecognizer，然后执行所有的手势识别
#### 解释一下页面的渲染的过程
渲染过程，包括像动画效果，我们项目中的inMainThread（这里是因为mainThread的runloopCallOut是在Pop和Push之间，应该也是在Beforwaiting和AfterWaiting之间），都是在beforewaiting(即将休眠的时候)的时候被系统捕获这些被打了标记的对象，然后统一作出处理。
layer会调用[CALyer display]，进入到真正的绘制过程。接下来就是通过判断看是否是异步绘制代理方法func display(_ layer: CALayer)，如果有异步绘制的代理方法，则走异步绘制func display(_ layer: CALayer)方法
如果没有的话走系统绘制方法。
系统绘制：
layer会创建backingStore获取上下文CGContextRef,
接下来判断是否有layer.delegate代理
如果有：
调用layer.delegate drawLayer:inContext:，
接着返回UIVew drawRect回调，让我们在系统绘制的基础上，再做一些其他的事情
如果没有：CALayer drawInContext
走完后，CALayer上传backingStore给GPU，结束
异步绘制：
直接走func display(_ layer: CALayer)方法，里面dispatchAsyncGlobal，然后再dispatch到Main的过程中吧异步生成的东西赋值给layer.contents，结束

#### 什么是异步绘制
layer会创建backingStore获取上下文CGContextRef,
接下来判断是否有代理
如果有：
调用layer.delegate drawLayer:inContext:，
接着返回UIVew drawRect回调，让我们在系统绘制的基础上，再做一些其他的事情
如果没有：CALayer drawInContext

走完后，CALayer上传backingStore给GPU，结束
#### 8
8
#### 9
9
#### 10
10
#### 11
11
#### 12
12
#### 13
13
#### 14
14
#### 15
15