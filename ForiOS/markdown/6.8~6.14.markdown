[toc]
## 6.9
#### SEL和IMP的区别
SEL是方法编号，也是方法名，在dyld加载镜像到内存时，通过_read_image方法加载到内存的表中了
IMP是函数实现指针，找IMP就是找函数实现的过程
SEL和IMP的关系就可以解释为：
SEL就相当于书本的⽬录标题
IMP就是书本的⻚码
函数就是具体页码对应的内容
#### autoreleasepool实现原理
objc_autoreleasePoolPush和objc_autoreleasePoolPop方法，实际调用的是AutoreleasePoolPage的Push和Pop方法。
AutoreleasePoolPage是一个双向链表的节点，里面有字段
magic表示是否完整
child,parent父节点和子节点
thread:当前线程
next表示autorelease对象的下一个位置，next == begin()时为空，next == end()时为pool满了
当前 page 存在且没有满时，直接将对象添加到当前 page 中，即 next 指向的位置；
当前 page 存在且已满时next == end()，创建一个新的 page ，并将对象添加到新创建的 page 中；
当前 page 不存在时，即还没有 page 时，创建第一个 page，next == begin() ，并将对象添加到新创建的 page
哨兵对象：
POOL_BOUNDARY 是一个边界对象 nil,之前的源代码变量名是 POOL_SENTINEL哨兵对象,用来区别每个page即每个 AutoreleasePoolPage 边界
#### NSThread、NSRunLoop 和 NSAutoreleasePool
苹果不允许直接创建 RunLoop，它只提供了两个自动获取的函数：CFRunLoopGetMain()和 CFRunLoopGetCurrent()。 这两个函数内部的逻辑大概是
线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）
NSAutoreleasePool 中还提到，每一个线程都会维护自己的 autoreleasepool 堆栈。换句话说 autoreleasepool 是与线程紧密相关的，每一个 autoreleasepool 只对应一个线程。(runloop也是一个)
总而言之：每一个 autoreleasepool 只对应一个线程。每一个线程拥有一个专属的 NSRunLoop 对象。

## 6.10
### runtime相关问题
#### runtime的内存模型（isa、对象、类、metaclass、结构体的存储信息等）
```
typedef struct objc_class *Class;

struct objc_class {
    Class isa  OBJC_ISA_AVAILABILITY;
#if !__OBJC2__
    Class super_class                      OBJC2_UNAVAILABLE;  // 父类
    const char *name                        OBJC2_UNAVAILABLE;  // 类名
    long version                            OBJC2_UNAVAILABLE;  // 类的版本信息，默认为0
    long info                              OBJC2_UNAVAILABLE;  // 类信息，供运行期使用的一些位标识
    long instance_size                      OBJC2_UNAVAILABLE;  // 该类的实例变量大小
    struct objc_ivar_list *ivars            OBJC2_UNAVAILABLE;  // 该类的成员变量链表
    struct objc_method_list **methodLists  OBJC2_UNAVAILABLE;  // 方法定义的链表
    struct objc_cache *cache                OBJC2_UNAVAILABLE;  // 方法缓存
    struct objc_protocol_list *protocols    OBJC2_UNAVAILABLE;  // 协议链表
#endif

} OBJC2_UNAVAILABLE;

}
```
isa :需要注意的是在Objective-c中，所有类自身也是一个对象，因为这个对象Class里面也有一个isa指针，它指向mateClass(元类)
里面有图https://developer.aliyun.com/ask/282811

元类（Meta Class）：是一个类对象的类，即：Class的类，这里保存了类方法等相关信息
NSObject的metaClass的isa指向的是自己本身，
而NSObject的metaClass的superClass指向的是NSObject
#### 为什么要设计metaclass
万物皆对象啊，这样类作为对象也能用消息机制，让每一个类都有自己的metaclass有利于单一职责，不然就全写在NSObjct的Metaclass了
#### id的本质是什么呢
```
/// An opaque type that represents an Objective-C class.
typedef struct objc_class *Class;

/// Represents an instance of a class.
struct objc_object {
    Class isa  OBJC_ISA_AVAILABILITY;
};

/// A pointer to an instance of a class.
typedef struct objc_object *id;
```
id也就是这个struct objc_object结构体的指针
它包括一个isa指针，指向的是这个对象的类对象,一个对象实例就是通过这个isa找到它自己的Class，而这个Class中存储的就是这个实例的方法列表、属性列表、成员变量列表等相关信息的。
#### class_copyIvarList & class_copyPropertyList区别
```
{
    NSString *str;
}
@property NSString *property;

//class_copyIvarList
str
_property
//class_copyPropertyList
property
```
class_copyIvarList:能够获取.h和.m中的所有属性以及大括号中声明的变量，获取的属性名称有下划线(大括号中的除外)。
class_copyPropertyList:只能获取由property声明的属性，包括.m中的，获取的属性名称不带下划线。
所以OC中没有真正的私有属性
#### category如何被加载的,两个category的load方法的加载顺序，两个category的同名方法的加载顺序呢，initialize,在继承关系中他们有什么区别
+load 方法是main加载的时候调用。不管这个类会不会用都会被调用。
先调用父类的load，然后是自己的
category的load是按照编译顺序来的，先编译的先调用，后编译的后调用

initialize其实是类第一次被使用到的时候会被调用在main之后
依旧是先调用父类的initialize，然后是自己的
category的initialize是按照编译顺序来的，所有的initialize只调用一次，也就是最后编译的那个category中的initialize方法

还能看出如果在A中load里调用B对象，那么B对象会先load，然后调用B的initialize，这个initialize是在main之前调用，用的消息转发机制
```
2020-06-11 00:17:05.142181+0800 CMDTest[18977:6172550] mainStart load
2020-06-11 00:17:05.142721+0800 CMDTest[18977:6172550] SuperClass load
2020-06-11 00:17:05.142753+0800 CMDTest[18977:6172550] main load
2020-06-11 00:17:05.142786+0800 CMDTest[18977:6172550] num1 load
2020-06-11 00:17:05.142817+0800 CMDTest[18977:6172550] num2 load
main Start
2020-06-11 00:17:05.142969+0800 CMDTest[18977:6172550] SuperClass initialize
2020-06-11 00:17:05.143013+0800 CMDTest[18977:6172550] num2 initialize
2020-06-11 00:17:05.143042+0800 CMDTest[18977:6172550] ggsimida
Program ended with exit code: 0
```
#### category & extension区别，能给NSObject添加Extension吗，结果如何
category:
运行时添加分类属性/协议/方法
分类添加的方法会“覆盖”原类方法，因为方法查找的话是从头至尾，一旦查找到了就停止了
同名分类方法谁生效取决于编译顺序，读取的信息是倒叙的，所以编译越靠后的越先读入
extension:
编译时决议
只有.h文件，只以声明的形式存在，所以不能为系统类添加扩展
这东西就是用来访问自己写的类的私有方法的
#### 消息转发机制，消息转发机制和其他语言的消息机制优劣对比

#### 在方法调用的时候，方法查询-> 动态解析-> 消息转发 之前做了什么
检查selector是否需要忽略，比如retain和release这样的函数
检查target是不是为nil，如果是nil的话msg_send就会被忽略掉
之后就是在缓冲中找有没有方法，没有就去对象的method_list找，还没有就去父类中去找，还没找到就会到_objc_msgForward消息转发，还不行还有最后的一次机会包装NSInvocation给开发，还不行就崩溃了
#### IMP、SEL、Method的区别和使用场景
SEL是方法编号，也是方法名，在dyld加载镜像到内存时，通过_read_image方法加载到内存的表中了
IMP是Method实现指针，找IMP就是找函数实现的过程
SEL和IMP的关系就可以解释为：
SEL就相当于书本的⽬录标题
IMP就是书本的⻚码
Method就是具体页码对应的内容
#### 说说消息转发机制的优劣
11
#### weak的实现原理？SideTable的结构是什么样的
为了管理所有对象的引用计数和weak指针，苹果创建了一个全局的SideTables，虽然名字后面有个不过他其实是一个全局的Hash表
实现步骤
1、初始化时：runtime会调用objc_initWeak函数，初始化一个新的weak指针指向对象的地址。
2、添加引用时：objc_initWeak函数会调用 objc_storeWeak() 函数， objc_storeWeak() 的作用是更新指针指向，创建对应的弱引用表。
3、释放时，调用clearDeallocating函数。clearDeallocating函数首先根据对象地址获取所有weak指针地址的数组，然后遍历这个数组把其中的数据设为nil，最后把这个entry从weak表中删除，最后清理对象的记录。
```
struct SideTable {
// 因为对象引用计数相关操作应该是原子性的。不然如果多个线程同时去写一个对象的引用计数，那就会造成数据错乱，失去了内存管理的意义
    spinlock_t slock;
    // 引用计数的 hash 表
    RefcountMap refcnts;
    // weak 引用全局 hash 表
    weak_table_t weak_table;
}
```

https://www.jianshu.com/p/ef6d9bf8fe59
#### 关联对象的应用？系统如何实现关联对象的
13
#### 关联对象的如何进行内存管理的？关联对象如何实现weak属性
14
#### Autoreleasepool的原理？所使用的的数据结构是什么
15



#### ARC的实现原理？ARC下对retain & release做了哪些优化
16
#### ARC下哪些情况会造成内存泄漏
17
#### Method Swizzle注意事项
18
#### 属性修饰符atomic的内部实现是怎么样的?能保证线程安全吗
19
#### iOS 中内省的几个方法有哪些？内部实现原理是什么
20
#### class、objc_getClass、object_getclass 方法有什么区别?
21
https://github.com/colourful987/bytedance-alibaba-interview

## 6.11
### 内存相关问题
#### 有哪些检测内存泄露的方式
Xcode自带的Analyze
Instrument的Allocation和Leak
第三方腾讯出的MLeaksFinder

#### MRC下的Setter和Getter如何重写
set是先释放旧值，再retain新值
```
- (void)setName:(NSString *)name {
    if (_name != name) {
        [_name release];
        _name = [brand retain];
    }
}
```
get是先retain，然后再autorelease，保证再取值的时候有值，在不需要之后释放
```
- (NSString *)name {
    return [[_name retain] autorelease];
}
```
重写dealloc,但是不要调用，会崩溃
```
- (void)dealloc {
    [_name release];
    [super dealloc];
}
```

#### 容易造成内存泄露的情况和处理情况
循环引用实质：多个对象之间相互强引用而不能释放
delegate：用weak修饰delegate
block：用__weak，或者用__block在合适的时候置为nil。在block中使用__strong是怕在block中对象被释放掉，让在Block期间被持有，block结束后再释放
NSTimer：在控制器内Timer作为属性的时候会强引用控制器，所以会相互引用，只需要在合适的时候将将定时器 invalidate 并置为 nil 即可
try/catch：EOC

#### 野指针和悬垂指针
OC野指针和悬垂指针(迷途指针都是一回事)，即指针指向的对象已经被回收掉了
C语言分悬垂指针和野指针：
悬垂指针：指针指向的内存已经被释放了，但是指针还在，这个就是悬垂指针（）
野指针：指针指向的对象已经被回收掉了.这个指针就叫做野指针.

#### 说一下对strong,copy,assign,weak关键字的理解
copy   对应的所有修饰符是 __strong
retain 对应的所有修饰符是 __strong
strong 对应的所有修饰符是 __strong
assign 对应的所有修饰符是 __unsafe_unretain
weak   对应的所有修饰符是 __weak
strong持有该对象，引用计数+1
weak指向对象但是不持有对象，引用计数也不会加1，weak不可以修饰基础数据类型
assign是指针赋值修饰基本数据类型，如NSInterger和CGFloat，也可以修饰对象，会有警告，脱离作用域就被释放了，再访问assgin修饰的对象会报野指针
copy关键字和strong类似，copy多用于修饰有可变类型的不可变对象NSString,NSArray,NSDictionary上，计数设置为1。（引用场景：类似于重新创造了一只狗，并给这只狗套上了一条绳）
__unsafe_unretain可以类似比较assign，不安全
__autoreleasing就是把对象扔autoreeasepool中

#### 是否了解深拷贝和浅拷贝的概念，集合类深拷贝如何实现
对不可变的非集合对象，copy 是指针拷贝，mutablecopy 是内容拷贝
对于可变的非集合对象，copy，mutablecopy 都是内容拷贝
对不可变的数组、字典、集合等集合类对象，copy 是指针拷贝，mutablecopy 是内容拷贝
对于可变的数组、字典、集合等集合类对象，copy，mutablecopy 都是内容拷贝
集合类深拷贝用
```
[[NSArray alloc] initWithArray:@[] copyItems:YES];
```

#### 使用自动引用计数应遵循的原则
不能使用retain、release、retainCount、autorelease
不可以使用NSAllocateObject、NSDeallocateObject
不需要显示的调用Dealloc。
使用@autoreleasePool来代替NSAutoreleasePool
不可以使用区域NSZone。
显示转换id和void*。

#### 能不能简述一下 Dealloc 的实现机制
Dealloc 的实现机制是内容管理部分的重点，把这个知识点弄明白，对于全方位的理解内存管理的只是很有必要。
dealloc时调用
1._objc_rootDealloc
2.rootDealloc()
3.object_dispose()
4.objc_destructInstance()
    4.1:object_cxxDestruct:判断有没有关联Cpp的东西，删除掉
    4.2:_object_remove_assocations:去除和这个对象assocate的对象
    4.3:objc_clear_deallocating:清空引用计数表并清除弱引用表，将所有weak引用指nil（这也就是weak变量能安全置空的所在）

#### 内存中的5大区分别是什么
栈区(stack):由编译器自动分配释放存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。
堆区(heap):一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。注意它与 数据结构中的堆是两回事，分配方式倒是类似于链表。
全局区(静态区)(static):全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。
常量区:常量就是放在这里的。程序结束后由系统释放。
程序代码区:存放函数体的二进制代码。

#### 内存管理默认的关键字是什么
MRC：atomic, readwrite, retain
ARC：atomic, readwrite, strong

#### 内存管理方案
taggedPointer:由于NSNumber、NSDate一类的变量本身的值需要占用的内存大小常常不需要8个字节，所以将一个对象的指针拆成两部分，一部分直接保存数据，另一部分作为特殊标记，表示这是一个特别的指针，不指向任何一个地址，将值直接存储到了指针本身里。但是TaggedPointer因为并不是真正的对象，而是一个伪对象，所以你如果完全把它当成对象来使，可能会让它露马脚。所有对象都有 isa指针，而TaggedPointer其实是没有的
具体的看文章https://www.jianshu.com/p/c9089494fb6c

NONPOINTER_ISA--(非指针型的 isa):在64位架构下，isa指针是占64比特位的，实际上只有30多位就已经够用了，为了提高利用率，剩余的比特位存储了内存管理的相关数据内容
第一位的0或1代表是纯地址型isa指针，还是NONPOINTER_ISA指针。
第二位，代表是否有关联对象
第三位代表是否有C++代码。
接下来33位代表指向的内存地址
接下来有弱引用的标记
接下来有是否delloc的标记....等等

散列表:复杂的数据结构，包括了引用计数表和弱引用表通过SideTables()结构来实现的，SideTables()结构下，有很多 SideTable 的数据结构。而sideTable 当中包含了自旋锁，引用计数表，弱引用表。SideTables()实际上是一个哈希表，通过对象的地址来计算该对象的引用计数在哪个sideTable中。
SideTables表在64位系统中，有64张SideTable表
每一张SideTable主要是由三部分组成。自旋锁、引用计数表、弱引用表。
全局的引用计数之所以不存在同一张表中，是为了避免资源竞争，解决效率的问题。
引用计数表中引入了分离锁的概念，将一张表分拆成多个部分，对他们分别加锁，可以实现并发操作，提升执行效率

#### SideTables和AutorealesePool
???
 
#### 64bit和32bit占用内存
64bit和32bit下long和char所占字节是不同的
char:1字节(ASCII2=256个字符)
char*(即指针变量):4个字节(32位的寻址空间是2,即32个bit，也就是4个字节。同理 64 位编译器为 8 个字节)
int:4个字节范围-2147483648~>2147483647
long:4个字节 范围和int一样 64位下8个字节，范围
-9223372036854775808~9223372036854775807
longlong:8个字节范围-9223372036854775808~9223372036854775807
float:4个字节
double:8个字节

#### 讲一下@dynamic和@synthesize关键字?
@property有两个对应的词，一个是@synthesize，一个是@dynamic。如果@synthesize和@dynamic都没写，那么默认的就是@syntheszie var = _var;
创造一个带下划线前缀的实例变量名，同时使用这个属性生成getter和setter方法。如果不想自动合成就用@dynamic告诉编译器,属性的setter与getter方法由用户自己实现，不自动生成。这里就涉及到Runtime的动态添加方法的知识点。

